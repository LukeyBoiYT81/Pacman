<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pac‑Man — Final Fixed Spawns</title>
<style>
  :root{--bg:#000;--wall:#002b3a;--dot:#ffd700}
  html,body{height:100%;margin:0;background:var(--bg);display:flex;align-items:center;justify-content:center;font-family:system-ui,Segoe UI,Roboto,Arial}
  #game{background:#000;border:6px solid #111;display:block}
  .hud{position:fixed;left:12px;top:12px;color:#ddd;font-size:14px}
  button{margin-left:8px}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hud">Score: <span id="score">0</span> Lives: <span id="lives">3</span> <button id="restart">Restart</button></div>
<script>
/* Final working Pac-Man single-file: robust spawn-fixing + gameplay
   - Ensures spawns are never inside walls (BFS with clamped start and 2D visited array)
   - Full playable loop with pellets, power-pellets, frightened mode, eating ghosts
   - Ghosts use simple random movement at intersections
*/

const TILE = 20;
// Map legend: 1 = wall, 0 = small pellet, 2 = empty floor, 3 = power pellet
const ORIG_MAP = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1],
  [1,0,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1],
  [1,3,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,3,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],
  [1,0,0,0,0,0,0,1,1,0,0,0,0,2,0,0,0,0,1,1,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,0,1,1,1,1,1,0,2,0,1,1,1,1,1,0,1,1,1,1,1,1],
  [2,2,2,2,2,1,0,1,1,1,1,1,0,2,0,1,1,1,1,1,0,1,2,2,2,2,2],
  [1,1,1,1,1,1,0,1,1,0,0,0,0,2,0,0,0,0,1,1,0,1,1,1,1,1,1],
  [2,2,2,2,2,1,0,1,1,0,1,1,1,1,1,1,1,0,1,1,0,1,2,2,2,2,2],
  [1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,1,1,1,1,0,1,1,1,0,1,2,2,2,1,0,1,1,1,0,1,1,1,1,0,1],
  [1,3,0,0,0,0,0,1,1,1,0,1,2,2,2,1,0,1,1,1,0,0,0,0,0,3,1],
  [1,1,1,1,1,1,0,1,1,1,0,1,1,2,1,1,0,1,1,1,0,1,1,1,1,1,1],
  [2,2,2,2,2,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,1,2,2,2,2,2],
  [1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,1,1,0,0,0,0,2,0,0,0,0,1,1,0,0,0,0,0,0,1],
  [1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],
  [1,3,0,0,0,0,0,0,0,0,0,1,1,2,1,1,0,0,0,0,0,0,0,0,0,3,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

const ROWS = ORIG_MAP.length;
const COLS = ORIG_MAP[0].length;

const canvas = document.getElementById('game');
canvas.width = COLS * TILE;
canvas.height = ROWS * TILE;
const ctx = canvas.getContext('2d');

const WALL = 1, DOT = 0, EMPTY = 2, POWER = 3;

function inBounds(x,y){ return Number.isInteger(x) && Number.isInteger(y) && x >= 0 && y >= 0 && x < COLS && y < ROWS; }
function isWalkable(x,y){ return inBounds(x,y) && ORIG_MAP[y][x] !== WALL; }
function centerX(col){ return col * TILE + TILE/2; }
function centerY(row){ return row * TILE + TILE/2; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

// BFS to find nearest non-wall tile (safe: clamps start and uses 2D visited boolean array)
function findNearestEmptyTile(sx, sy){
  sx = Math.round(sx); sy = Math.round(sy);
  if(!inBounds(sx,sy)){
    sx = clamp(sx,0,COLS-1); sy = clamp(sy,0,ROWS-1);
  }
  const visited = Array.from({length: ROWS}, ()=>Array(COLS).fill(false));
  const q = [{x:sx,y:sy}]; let qi=0; visited[sy][sx] = true;
  while(qi < q.length){
    const {x,y} = q[qi++];
    if(ORIG_MAP[y][x] !== WALL) return {x,y};
    for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
      const nx = x + dx, ny = y + dy;
      if(nx >= 0 && ny >= 0 && nx < COLS && ny < ROWS && !visited[ny][nx]){ visited[ny][nx] = true; q.push({x:nx,y:ny}); }
    }
  }
  // fallback scan
  for(let ry=0; ry<ROWS; ry++) for(let rx=0; rx<COLS; rx++) if(ORIG_MAP[ry][rx] !== WALL) return {x:rx,y:ry};
  return {x:0,y:0};
}

// compute fixed spawn points
const desiredPac = {x:13, y:17};
const mid = Math.floor(COLS/2);
const desiredGhosts = [{x:mid, y:11},{x:mid-1,y:11},{x:mid+1,y:11},{x:mid+2,y:11}];
const FIXED_PAC = findNearestEmptyTile(desiredPac.x, desiredPac.y);
const FIXED_GHOSTS = desiredGhosts.map(g=>findNearestEmptyTile(g.x,g.y));
// safety asserts
if(!isWalkable(FIXED_PAC.x, FIXED_PAC.y)) console.error('Pac spawn not walkable', FIXED_PAC);
FIXED_GHOSTS.forEach((g,i)=>{ if(!isWalkable(g.x,g.y)) console.error('Ghost spawn not walkable',i,g); });

// game state
let map = ORIG_MAP.map(r=>r.slice()); // mutable map
let score = 0, lives = 3;
const hudScore = document.getElementById('score');
const hudLives = document.getElementById('lives');

document.getElementById('restart').addEventListener('click', ()=>{ resetAll(); });

// Pac-Man entity
const pac = {
  x: centerX(FIXED_PAC.x), y: centerY(FIXED_PAC.y),
  dir: {x:0,y:0}, desired: {x:0,y:0}, speed: 5 * TILE, radius: TILE*0.45
};

// Ghost entity factory
function makeGhost(color, spawn){
  return { color, x: centerX(spawn.x), y: centerY(spawn.y), dir:{x:0,y:0}, speed: 3.6 * TILE, state:'normal' };
}
let ghosts = FIXED_GHOSTS.map((s,i)=> makeGhost(['#ff0000','#ff77ff','#00ffff','#ff8800'][i], s));

// frightened timer
let frightenedUntil = 0;
let ghostEatMultiplier = 1;

// input
const keys = {};
window.addEventListener('keydown', e=>{ keys[e.key] = true; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d'].includes(e.key)) e.preventDefault(); updateDesired(); });
window.addEventListener('keyup', e=>{ keys[e.key] = false; });
function updateDesired(){ const mapKey = {ArrowLeft:[-1,0],a:[-1,0],ArrowRight:[1,0],d:[1,0],ArrowUp:[0,-1],w:[0,-1],ArrowDown:[0,1],s:[0,1]}; for(const k in mapKey) if(keys[k]){ pac.desired.x = mapKey[k][0]; pac.desired.y = mapKey[k][1]; return; } }

function cellAt(col,row){ if(row<0||col<0||row>=ROWS||col>=COLS) return WALL; return map[row][col]; }
function canMoveTo(col,row){ return cellAt(col,row) !== WALL; }

function atCenter(entity){ const col = Math.round((entity.x - TILE/2)/TILE); const row = Math.round((entity.y - TILE/2)/TILE); return Math.abs(entity.x - centerX(col)) < 0.5 && Math.abs(entity.y - centerY(row)) < 0.5; }

function startFrightened(){ const now = performance.now(); frightenedUntil = now + 8000; ghostEatMultiplier = 1; ghosts.forEach(g=>{ if(g.state === 'normal'){ g.state = 'frightened'; g.speed = 2.2 * TILE; g.dir.x *= -1; g.dir.y *= -1; }}); }
function endFrightened(){ ghosts.forEach(g=>{ if(g.state === 'frightened') { g.state = 'normal'; g.speed = 3.6 * TILE; }}); }

function chooseRandomDir(g){ const col = Math.round((g.x - TILE/2)/TILE); const row = Math.round((g.y - TILE/2)/TILE); const candidates = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}]; const options = []; for(const d of candidates){ const nc = col + d.x, nr = row + d.y; if(canMoveTo(nc,nr)){ if(d.x === -g.dir.x && d.y === -g.dir.y) continue; options.push(d); }} if(options.length === 0){ for(const d of candidates){ const nc = col + d.x, nr = row + d.y; if(canMoveTo(nc,nr)) options.push(d); }} if(options.length === 0) return {x:0,y:0}; return options[Math.floor(Math.random()*options.length)]; }

function moveGhostTowards(g, targetCol, targetRow){ const col = Math.round((g.x - TILE/2)/TILE); const row = Math.round((g.y - TILE/2)/TILE); const candidates = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}]; let best=null; let bestD=1e9; for(const d of candidates){ const nc = col + d.x, nr = row + d.y; if(!canMoveTo(nc,nr)) continue; const dx = nc - targetCol, dy = nr - targetRow; const dist = Math.hypot(dx,dy); if(dist < bestD){ bestD = dist; best = d; }} return best || {x:0,y:0}; }

function updatePac(dt){ // dt in seconds
  updateDesired();
  const col = Math.round((pac.x - TILE/2)/TILE); const row = Math.round((pac.y - TILE/2)/TILE);
  if(atCenter(pac)){
    pac.x = centerX(col); pac.y = centerY(row);
    // try desired
    const ndc = col + pac.desired.x, ndr = row + pac.desired.y;
    if(canMoveTo(ndc, ndr)) pac.dir = {x: pac.desired.x, y: pac.desired.y};
    // if current blocked
    const ac = col + pac.dir.x, ar = row + pac.dir.y; if(!canMoveTo(ac,ar)) pac.dir = {x:0,y:0};
    // eat pellets
    const cell = cellAt(col,row);
    if(cell === DOT){ map[row][col] = EMPTY; score += 10; hudScore.textContent = score; }
    else if(cell === POWER){ map[row][col] = EMPTY; score += 50; hudScore.textContent = score; startFrightened(); }
  }
  pac.x += pac.dir.x * pac.speed * dt;
  pac.y += pac.dir.y * pac.speed * dt;
}

const pen = {col: Math.floor(COLS/2), row: 11};

function updateGhost(g, dt){ const col = Math.round((g.x - TILE/2)/TILE); const row = Math.round((g.y - TILE/2)/TILE);
  if(atCenter(g)){
    g.x = centerX(col); g.y = centerY(row);
    if(g.state === 'eaten'){
      if(col === pen.col && row === pen.row){ g.state = 'normal'; g.speed = 3.6 * TILE; }
      g.dir = moveGhostTowards(g, pen.col, pen.row);
    } else if(g.state === 'frightened'){
      g.dir = chooseRandomDir(g);
    } else {
      // normal: wander randomly (can be improved to chase)
      g.dir = chooseRandomDir(g);
    }
  }
  g.x += g.dir.x * g.speed * dt;
  g.y += g.dir.y * g.speed * dt;
}

function checkCollisions(){ for(const g of ghosts){ const dx = g.x - pac.x, dy = g.y - pac.y; const d = Math.hypot(dx,dy); if(d < TILE*0.5){ if(g.state === 'frightened'){ // eat ghost
        g.state = 'eaten'; g.speed = 5.6 * TILE; ghostEatMultiplier = ghostEatMultiplier || 1; score += 200 * ghostEatMultiplier; ghostEatMultiplier *= 2; hudScore.textContent = score; // head home
        // reverse to go home faster
        g.dir.x *= -1; g.dir.y *= -1;
      } else if(g.state === 'normal'){
        // Pac-Man dies
        lives--; hudLives.textContent = lives; if(lives <= 0){ setTimeout(()=>{ alert('Game Over — Score: '+score); resetAll(); }, 50); return; }
        setTimeout(()=>{ resetPositions(); }, 50);
        return;
      }
    }
  }}

function resetPositions(){ pac.x = centerX(FIXED_PAC.x); pac.y = centerY(FIXED_PAC.y); pac.dir = {x:0,y:0}; pac.desired = {x:0,y:0}; ghosts = FIXED_GHOSTS.map((s,i)=> makeGhost(['#ff0000','#ff77ff','#00ffff','#ff8800'][i], s)); }

function resetAll(){ map = ORIG_MAP.map(r=>r.slice()); score = 0; lives = 3; hudScore.textContent = score; hudLives.textContent = lives; resetPositions(); }

resetAll();

// main loop
let last = performance.now(); function loop(ts){ const dt = (ts - last)/1000; last = ts; if(frightenedUntil && ts >= frightenedUntil){ frightenedUntil = 0; endFrightened(); }
  updatePac(dt); for(const g of ghosts) updateGhost(g, dt); checkCollisions(); // win check
  if(!map.some(row => row.some(cell => cell === DOT || cell === POWER))){ // level complete
    map = ORIG_MAP.map(r=>r.slice()); // refill
    score += 1000; hudScore.textContent = score; resetPositions(); }
  draw(); requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// drawing
function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const v = map[r][c]; const x = c*TILE, y = r*TILE;
      if(v === WALL){ ctx.fillStyle = '#003'; ctx.fillRect(x,y,TILE,TILE); }
      else if(v === DOT){ ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(x+TILE/2,y+TILE/2,2.5,0,Math.PI*2); ctx.fill(); }
      else if(v === POWER){ ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(x+TILE/2,y+TILE/2,6,0,Math.PI*2); ctx.fill(); }
    }
  }
  // pac-man
  ctx.save(); ctx.translate(pac.x, pac.y);
  let ang = 0, mouth = 0.35; if(pac.dir.x === 1) ang = 0; else if(pac.dir.x === -1) ang = Math.PI; else if(pac.dir.y === 1) ang = Math.PI/2; else if(pac.dir.y === -1) ang = -Math.PI/2;
  ctx.fillStyle = '#ffeb3b'; ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0,pac.radius,ang+mouth,ang-mouth,true); ctx.closePath(); ctx.fill(); ctx.restore();
  // ghosts
  for(const g of ghosts){ ctx.save(); ctx.translate(g.x,g.y);
    if(g.state === 'eaten'){
      // eyes
      ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(-6,-2,4,0,Math.PI*2); ctx.arc(6,-2,4,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-4,-2,1.5,0,Math.PI*2); ctx.arc(8,-2,1.5,0,Math.PI*2); ctx.fill(); ctx.restore(); continue;
    }
    if(g.state === 'frightened'){
      const remaining = Math.max(0, frightenedUntil - performance.now());
      if(remaining < 2000 && Math.floor(performance.now()/200) % 2 === 0) ctx.fillStyle = '#fff'; else ctx.fillStyle = '#1e90ff';
    } else ctx.fillStyle = g.color;
    roundRect(ctx, -TILE*0.45, -TILE*0.45, TILE*0.9, TILE*0.9, 6); ctx.fill();
    // eyes
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(-6,-2,4,0,Math.PI*2); ctx.arc(6,-2,4,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-4 + g.dir.x*2, -2 + g.dir.y*2, 1.6,0,Math.PI*2); ctx.arc(8 + g.dir.x*2, -2 + g.dir.y*2, 1.6,0,Math.PI*2); ctx.fill();
    ctx.restore(); }
}

function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

// helper to trigger frightened when pac eats power
function startFrightened(){ const now = performance.now(); frightenedUntil = now + 8000; ghostEatMultiplier = 1; ghosts.forEach(g=>{ if(g.state === 'normal'){ g.state = 'frightened'; g.speed = 2.2 * TILE; g.dir.x *= -1; g.dir.y *= -1; }}); }
function endFrightened(){ ghosts.forEach(g=>{ if(g.state === 'frightened'){ g.state = 'normal'; g.speed = 3.6 * TILE; }}); }

// expose function for debugging in console
window.findNearestEmptyTile = findNearestEmptyTile;
</script>
</body>
</html>
